{"paragraphs":[{"text":"%md\n\n## Performing Neighborhood Aggregation\n\nGraphX has a mechanism to do **Neighborhood Aggregation** at each neighborhood level in the form of the **aggregateMessages** method. \n\nIt does it in two steps:\n\n1. In the first step (first function of the method), messages are send to the destination vertex or source vertex (similar to the Map function in MapReduce).\n2. In the second step (second function of the method), aggregation is done on these messages (similar to the Reduce function in MapReduce).\n\nConsider the following dataset:\n\n<p>\n<table width=200>\n\t<tr>\n\t\t<th>Follower</th>\n\t\t<th>Followee</th>\n\t</tr>\n\t<tr>\n\t\t<td>John</td>\n\t\t<td>Christ</td>\n\t</tr>\n\t<tr>\n\t\t<td>Pat</td>\n\t\t<td>Christ</td>\n\t</tr>\n\t<tr>\n\t\t<td>Gary</td>\n\t\t<td>Christ</td>\n\t</tr>\n\t<tr>\n\t\t<td>Kim</td>\n\t\t<td>Buddha</td>\n\t</tr>\n\t<tr>\n\t\t<td>Takeshi</td>\n\t\t<td>Buddha</td>\n\t</tr>\n</table>\n</p>\n\nWe want to find out how many followers each vertex has.\n\nLet us load this data in the form of two lists - _verticesList_ and _edgesList_.\n\nThe following is the content of _verticesList_:\n\n1,John,\n2,Christ,\n3,Pat,\n4,Gary,\n5,Kim,\n6,Buddha,\n7,Takeshi\n\nThe following is the content of _edgesList_:\n\n1,2,follows,\n3,2,follows,\n4,2,follows,\n5,6,follows,\n7,6,follows\n\nThe following code does the **Neighborhood Aggregation**:\n","dateUpdated":"2018-04-16T21:47:19-0400","config":{"editorSetting":{},"colWidth":12,"editorMode":"ace/mode/markdown","editorHide":true,"results":[{"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}}}],"enabled":true},"settings":{"params":{},"forms":{}},"results":{"code":"SUCCESS","msg":[{"type":"HTML","data":"<h2>Performing Neighborhood Aggregation</h2>\n<p>GraphX has a mechanism to do <strong>Neighborhood Aggregation</strong> at each neighborhood level in the form of the <strong>aggregateMessages</strong> method.</p>\n<p>It does it in two steps:</p>\n<ol>\n<li>In the first step (first function of the method), messages are send to the destination vertex or source vertex (similar to the Map function in MapReduce).</li>\n<li>In the second step (second function of the method), aggregation is done on these messages (similar to the Reduce function in MapReduce).</li>\n</ol>\n<p>Consider the following dataset:</p>\n<p>\n<table width=200>\n    <tr>\n        <th>Follower</th>\n        <th>Followee</th>\n    </tr>\n    <tr>\n        <td>John</td>\n        <td>Christ</td>\n    </tr>\n    <tr>\n        <td>Pat</td>\n        <td>Christ</td>\n    </tr>\n    <tr>\n        <td>Gary</td>\n        <td>Christ</td>\n    </tr>\n    <tr>\n        <td>Kim</td>\n        <td>Buddha</td>\n    </tr>\n    <tr>\n        <td>Takeshi</td>\n        <td>Buddha</td>\n    </tr>\n</table>\n</p>\n<p>We want to find out how many followers each vertex has.</p>\n<p>Let us load this data in the form of two lists - <em>verticesList</em> and <em>edgesList</em>.</p>\n<p>The following is the content of <em>verticesList</em>:</p>\n<p>1,John,\n<br  />2,Christ,\n<br  />3,Pat,\n<br  />4,Gary,\n<br  />5,Kim,\n<br  />6,Buddha,\n<br  />7,Takeshi</p>\n<p>The following is the content of <em>edgesList</em>:</p>\n<p>1,2,follows,\n<br  />3,2,follows,\n<br  />4,2,follows,\n<br  />5,6,follows,\n<br  />7,6,follows</p>\n<p>The following code does the <strong>Neighborhood Aggregation</strong>:</p>\n"}]},"apps":[],"jobName":"paragraph_1523929639460_473869614","id":"20160912-193112_902124268","dateCreated":"2018-04-16T21:47:19-0400","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1987"},{"text":"%spark\n\nimport org.apache.spark.graphx._\n\nval verticesList = sc.parallelize(List(\n    \"1,John\",\n    \"2,Christ\",\n    \"3,Pat\",\n    \"4,Gary\",\n    \"5,Kim\",\n    \"6,Buddha\",\n    \"7,Takeshi\"\n))\n\nval vertices = verticesList.map(_.split(\",\")).map( e => (e(0).toLong,e(1)))\n\nvertices.collect.foreach(println)\n\nval edgesList = sc.parallelize(List(\n    \"1,2,follows\",\n    \"3,2,follows\",\n    \"4,2,follows\",\n    \"5,6,follows\",\n    \"7,6,follows\"\n))\n\nval edges = edgesList.map(_.split(\",\")).map(e => Edge(e(0).toLong,e(1).toLong,e(2)))\n\nedges.collect.foreach(println)\n\nval graph = Graph(vertices,edges)\n\nval followerCount = graph.aggregateMessages[(Int)]( t => t.sendToDst(1), (a, b) => (a+b))\n\nfollowerCount.collect.foreach(println)\n","dateUpdated":"2018-04-16T21:47:19-0400","config":{"tableHide":false,"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523929639460_473869614","id":"20160912-191850_1936376550","dateCreated":"2018-04-16T21:47:19-0400","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1988"},{"dateUpdated":"2018-04-16T21:47:19-0400","config":{"editorSetting":{"language":"scala","editOnDblClick":false},"colWidth":12,"editorMode":"ace/mode/scala","results":{},"graph":{"mode":"table","height":300,"optionOpen":false,"keys":[],"values":[],"groups":[],"scatter":{}},"enabled":true},"settings":{"params":{},"forms":{}},"apps":[],"jobName":"paragraph_1523929639460_473869614","id":"20160912-191128_769552526","dateCreated":"2018-04-16T21:47:19-0400","status":"READY","errorMessage":"","progressUpdateIntervalMs":500,"$$hashKey":"object:1989"}],"name":"Lab 15.3 GraphX - Neighbourhood Aggregation","id":"2DE5HVEPE","angularObjects":{"2DBZ9228U:shared_process":[],"2DBPWG79N:shared_process":[]},"config":{"looknfeel":"default","personalizedMode":"false"},"info":{}}